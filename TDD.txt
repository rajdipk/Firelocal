FireLocal — Technical Details Document (TDD)

Purpose: single-source, developer-friendly TDD that describes what FireLocal is, how it behaves, and how to implement it. Designed so developers and AI agents can pick this up and build, test, and extend the system with minimum ambiguity.

1 — Executive summary

FireLocal is an offline-first, multi-platform, local datastore that provides a drop-in, 100%-API-compatible developer experience with common cloud document stores. It runs fully locally, offers a robust custom storage & indexing engine, and optionally syncs to a remote datastore(firestore) via a pluggable sync adapter configured by a .env file.
Goals:

100% Firestore API compatibility so developers switch with zero friction.

Local-first operation: all reads/writes happen locally with immediate responses.

Own storage engine (LSM-inspired, WAL + SST) for durability and performance.

Pluggable indexing with a powerful default (per-field + composite).

Rules compatibility using the same Firebase rules syntax/semantics.

Flexible sync: live, batch, background via a sync adapter.

Multi-platform via a core implemented in Rust (native + WASM) plus language bindings (JS, Dart, Kotlin, Swift, .NET, Python, etc.).

Zero friction change to apps: apps always use FireLocal API identical to Firestore’s API. Sync is optional and configured via .env.

2 — Non-functional targets

Durability: ACID-ish for single-document updates and batched writes; WAL-backed writes persisted before ack.

Latency: Local reads/writes should be sub-10ms in common cases (in-memory + index).

Throughput: Target thousands of writes/sec on desktop/server hardware; mobile constrained by device IO.

Storage: Compact SST format; compaction to remove tombstones.

Safety: Rules evaluated locally; credentials stored only if user enables sync; private keys kept out of source control recommended.

Compatibility: Must match Firestore semantics for queries, transactions, batches, snapshots, FieldValue operations, and snapshot event order.

3 — High-level architecture
+---------------------------+      +------------------+
|   Application (any lang)  | <--> | Language Binding |
+---------------------------+      +------------------+
                                        |
                                        v
                              +----------------------+
                              |    firelocal-core    |  (Rust crate / wasm)
                              | - Storage Engine     |
                              | - Index Engine       |
                              | - Query Engine       |
                              | - Rules Engine       |
                              | - Sync API (adapter) |
                              +----------------------+
                                        |
                  +---------------------+---------------------+
                  |                     |                     |
        Native File Backend        IndexedDB Backend      Sync Adapter(s)
        (FileStorageBackend)         (WASM)              (firebase, others)


Components:

firelocal-core — core logic (Rust)

StorageBackend — platform adapter (file, indexeddb)

IndexProvider — pluggable index implementations

RulesEngine — rules parser & evaluator

SyncAdapter — plugin to sync with Firebase or other backends

Bindings — thin language SDKs exposing Firestore-compatible API

CLI — developer tools (inspect, rules test, sync, export/import)

Daemon (optional) — firelocald for shared local DB across processes

4 — Data model & canonical paths

Firestore-like: collections and documents arranged in hierarchical paths.

Canonical document path: /collection/docId/subcollection/docId... (string normalized).

Each stored document record contains:

path (string)

fields (typed map)

create_time (ISO8601 / unix nanos)

update_time

version or revision (monotonic increasing number)

meta (optional user metadata)

Store internal keys as binary-encoded path segments for deterministic ordering and faster comparisons.

5 — Storage engine (design)

Core design: lightweight LSM-style log-structured store.

Components

Write-Ahead Log (WAL)

Append-only. Records every mutation (put/delete) with op id, txn id (if batch/txn), timestamp.

WAL flushed to disk before returning success (unless configured).

Memtable

In-memory key-value map of recent writes. Sorted for efficient flush.

SSTables (immutable)

Sorted on-disk immutable files. Built when memtable flushes.

Each SST contains keys, values and a small footer with min/max key, bloom filter metadata.

Compaction

Merge multiple SSTs, remove tombstones, shrink files and rebuild indexes.

Tombstones

Deletes are write entries; compaction removes stale entries.

Snapshots

Read-only point-in-time view using memtable + list of SSTs as of a snapshot token.

File layout (suggested)

wal/*.log

sst/{level}/{uuid}.sst

manifest.json (records SST files metadata, compaction history)

indexes/ (separate index files)

Durability options

Default: WAL fsync on every commit for strict durability.

Configurable: batched fsync for throughput.

6 — Indexing
Default indexing strategy (recommended)

Per-field sorted key index (B-tree-like or LSM storage): maps (collection_group, field, field_value, doc_path) → pointer to doc/value.

Composite indexes: support arbitrary combinations of fields in a stable order: (collection_group, fieldA_value, fieldB_value, ..., doc_path) → pointer.

Collection group indexing: index entries grouped by collection name regardless of path depth (supporting collectionGroup() queries).

Index files stored separately; updated on document put/delete; compacted with data compaction.

Pluggable interface

Define IndexProvider trait in core:

trait IndexProvider {
    fn initialize(&self, config: IndexConfig) -> Result<()>;
    fn on_put(&self, doc_path: &str, doc: &Document) -> Result<()>;
    fn on_delete(&self, doc_path: &str) -> Result<()>;
    fn query(&self, q: &QueryAst) -> Result<Vec<DocumentKey>>;
}


Bindings/config can register custom providers (in-process or remote).

7 — Query engine & semantics

Query AST built from Firestore-style query calls: filters, orderBy, startAt/endAt, limit, offset (if supported).

Query planning:

Check for matching composite index.

If none, fallback to single-field indexes.

If no applicable index, fallback to collection scan (but ideally surface an error suggesting index).

Query result ordering must match Firestore semantics (respecting orderBy and where combos).

Support in, array-contains, array-contains-any, array-not-in semantics identical to Firestore semantics & edge cases.

8 — API compatibility & bindings

Design principle: API parity. For each language provide objects, methods and behaviors that match Firestore.

Core API surface (example identifiers)

Firelocal (root) / Firestore equivalent

CollectionReference (collection())

DocumentReference (doc())

Query (where(), orderBy(), limit(), get(), onSnapshot())

WriteBatch / batch()

Transaction / runTransaction()

FieldValue helpers: serverTimestamp(), increment(), arrayUnion(), arrayRemove(), deleteField()

GeoPoint, Timestamp

Example (pseudo-JS / pseudo-Dart identical to Firestore):
const db = Firelocal.initialize();
const docRef = db.collection('users').doc('alice');
await docRef.set({name: 'Alice', age: 30});
const snapshot = await db.collection('users').where('age', '>', 25).get();
snapshot.forEach(doc => console.log(doc.id, doc.data()));


Bindings must preserve:

promise/async semantics in JS

Futures in Dart

exceptions and error types aligned to platform idioms

9 — Transactions & Batch semantics
Batch writes

Atomic group of writes applied locally in a single commit.

Persisted to WAL with a batch id; either all applied or none in terms of visibility.

For sync: batch mapped to atomic remote writes where possible.

Transactions

Optimistic concurrency model like Firestore: read docs, client performs local mutations, commit tries to apply only if read version unchanged (or using last-write-wins depending on config).

Local transaction semantics must mirror Firestore behaviour for conflict detection and retries.

API: runTransaction(async (tx) => { const doc = await tx.get(docRef); tx.set(docRef, {...}); });

10 — Rules engine

Syntax: identical to Firebase rules (support rules_version = '2'; and service cloud.firestore { ... }).

Evaluation context: request.auth, request.resource, resource, request.time, get(), exists() etc.

Behavior: evaluate on local read/write and deny/allow accordingly. Denied operations raise the same errors as Firestore would.

Testing: CLI command firelocal rules test --cases rules.test.json. Support small DSL for test cases.

Upload: firelocal rules push --project <id> uses Firebase credentials to push rules file.

11 — Sync adapter (firebase) — design

Role: optional module that translates FireLocal change feed to Firestore API and vice versa.

Key concepts

Change feed / op log: FireLocal maintains an ordered list of local changes with statuses (pending, in_flight, synced, failed). Sync agent reads this feed.

Push: local -> remote (batched or per-op). Maintains mapping of local op id -> remote op id.

Pull: remote -> local (listeners or periodic pulls).

Authentication: uses credentials provided via .env or runtime config. No hardcoding.

Modes: live, batch, background, off.

live: open persistent listeners; push immediately on local writes.

batch: manual or scheduled batched pushes/pulls.

background: OS-scheduled background work; mobile best-effort.

Conflict resolution (pluggable)

Default strategies:

serverWins

clientWins

Expose customResolver(localDoc, remoteDoc) => resolvedDoc

Provide hooks for logging & reporting conflicts.

Reliability

Retry policy with exponential backoff for transient errors.

Idempotency: use stable operation ids and Firestore document version checks to avoid duplicate writes.

12 — Configuration & .env example

Place .env in project root or pass a path into initialization.

# FireLocal config
FIRELOCAL_PROJECT_ID=my-project
FIRELOCAL_DB_PATH=./.firelocal/data
FIRELOCAL_SYNC_MODE=live            # live|batch|background|off
FIRELOCAL_SYNC_INTERVAL=300         # seconds for batch/background

# Firebase credentials (only if syncing)
FIREBASE_API_KEY=...
FIREBASE_APP_ID=...
FIREBASE_PROJECT_ID=...
FIREBASE_CLIENT_EMAIL=service-account@...
FIREBASE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"


Security note: recommend using environment secret manager for production; never commit .env to VCS.

13 — CLI & developer tools

firelocal CLI commands:

firelocal init — create config & local DB folder.

firelocal start — run local daemon (optional).

firelocal inspect [path] — view docs, indexes, stats.

firelocal rules test --file rules.test.json — run rules test cases.

firelocal rules push --project <projectId> — push to Firebase.

firelocal sync [--mode live|batch|background] — run sync.

firelocal export --out export.json — export DB snapshot (for migration/testing).

firelocal import --file export.json — import snapshot.

firelocal compact — trigger compaction.

CLI returns structured JSON for AI agents by default (with --json) to ease automation.

14 — RPC & bindings contract

Core <-> Binding communication (Rust core exposed via FFI/WASM):

Exports (minimal set):

initialize(config_json: string) -> handle_id

close(handle_id)

put_doc(handle_id, doc_path, doc_bytes) -> op_result_json

get_doc(handle_id, doc_path) -> doc_bytes | null

query(handle_id, query_json) -> result_json

on_snapshot(handle_id, query_json, callback_handle) (subscribe)

run_transaction(handle_id, tx_ops_json) -> result

get_stats(handle_id) -> json

start_sync(handle_id, sync_config_json)

stop_sync(handle_id)

For WASM: use wasm-bindgen with JS-friendly APIs.

For Dart: use flutter_rust_bridge or FFI with generated bindings.

Bindings must be thin: translate platform Firestore API calls into canonical JSON that cores consume, and convert core responses back to platform types.

15 — Testing & QA
Unit tests (core)

Storage engine: WAL durability, memtable flush, compaction correctness, tombstone handling.

Index engine: index updates on put/delete, composite index query results.

Query engine: AST parsing, plan selection, ordering, cursors.

Rules engine: parse and evaluate example rules; test edge cases (auth null, get() function, time comparisons).

Transaction semantics: conflict detection, retry policy.

Snapshot ordering: ensure added/modified/removed lifecycle and order identical to Firestore.

Integration tests

End-to-end Behavior: create documents with nested subcollections, run queries, snapshot listeners emit expected changes.

Bindings: JS/Dart SDK runs basic examples and matches expected outputs.

Sync adapter: simulate remote changes and local writes; verify state convergence.

Acceptance tests (must pass)

A1: App built with Firestore API calls runs against FireLocal without changes.

A2: Adding .env with valid Firebase creds and FIRELOCAL_SYNC_MODE=live starts syncing with remote; local changes show in remote and vice versa.

A3: Rules denials prevent local operations same as remote denies.

A4: Compaction reduces disk usage after heavy deletes.

Test data & fixtures

Provide realistic fixture sets: nested collections, arrays, geoPoints, timestamps, fieldValue ops.

16 — Logging, metrics & observability

Structured logs (JSON) with levels: DEBUG/INFO/WARN/ERROR.

Metrics (exposed via a local metrics endpoint or files):

writes/sec, reads/sec, pending_ops_count, last_sync_time, sync_rate_success, compaction_time, disk_size.

Tracing: optional trace id propagation to correlate sync operations.

17 — Security & privacy

Local-only mode: no network calls, no secrets required.

If sync is enabled:

use secure storage for service account/private key (platform-specific).

allow users to provide tokens at runtime.

Limit exposure of private keys. Default .env usage discouraged in production—recommend secret managers.

18 — Performance & benchmarks

Create benchmark suite to measure:

Single-document read latency (cold/hot)

Single-document write latency (fsync on/off)

Query throughput for:

single-field indexed queries

composite-indexed queries

collection scans

Sync throughput with remote Firestore (ops/sec)

Disk usage and compaction impact

Benchmark targets to tune later; initial goal: local read < 10ms, write < 20ms on desktop.

19 — Roadmap & milestones (concrete)

M0: Repo & skeleton (1 week)

Create monorepo, rust crate skeleton, basic build pipeline, basic docs.

M1: Minimal store (Phase 1) (3–4 weeks)

WAL, memtable, SST, put/get/delete

Simple JS/Dart binding for tests

M2: Query + Index (Phase 2) (4–6 weeks)

Per-field index, composite index, queries, basic query planner

M3: API parity + snapshots (Phase 3) (3–4 weeks)

Collection/Document APIs, snapshot listeners, batches, transactions (local)

M4: Rules engine (2–3 weeks)

Parser, evaluator, CLI tests

M5: Sync adapter (firebase) (4–6 weeks)

live/batch/background, conflict resolution, .env integration

M6: CLI & release (2–3 weeks)

CLI commands, packaging, docs, release on pub/npm/native builds

M7: Bindings expansion & ecosystem (ongoing)

Add Kotlin, Swift, .NET, Python bindings, contributions

Timeline flexible — parallelize work across bindings and core where possible.

20 — Acceptance criteria & deliverables

For each milestone include:

Deliverables: code, tests, docs, example app.

Acceptance tests: defined in Section 15.

API spec: published in repo as API.md.

CLI: basic commands working on macOS/Linux/Windows.

Packaging: core compiled into wasm + native libs; bindings published (alpha).

21 — Developer & AI agent integration notes (how to automate)

To make it frictionless for AI code agents:

Provide machine-readable spec.json:

RPC methods, arguments, expected JSON shapes.

Provide unit test templates and fixtures in tests/fixtures.

Provide tasklist.json with small, testable tasks (e.g., implement WAL append, implement memtable flush).

For each task include:

inputs

expected_output

unit_test_id to pass

Provide contrib.md with coding style and CI checks.

Example spec.json snippet:

{
  "rpc": {
    "put_doc": {
      "args": ["handle_id", "doc_path", "doc_bytes"],
      "returns": {"status": "ok|error", "op_id": "string"}
    }
  }
}

22 — Example flows / sample behaviors
22.1 Local write + snapshot listener (expected behavior)

App calls db.collection('users').doc('a').set({name: 'A'}).

Core writes WAL, updates memtable, updates indexes, returns success.

Snapshot listener subscribed to users receives an added change with the doc.

Sync agent picks op from change feed (if sync enabled) and pushes to Firebase.

22.2 Offline-first with later sync

App offline → writes all operations to FireLocal.

App regains connectivity and .env configured → sync agent starts; pushes pending ops, pulls remote changes, resolves conflicts.

22.3 Rules denial

App attempts write violating rules.

RulesEngine evaluates and rejects locally with PERMISSION_DENIED error consistent with Firestore.

23 — Error codes & messages (canonical)

PERMISSION_DENIED — rules deny

NOT_FOUND — doc/collection not found

ALREADY_EXISTS — duplicate create in constrained contexts

ABORTED — txn aborted due to conflict

INTERNAL — core internal errors

UNAVAILABLE — sync remote unreachable

INVALID_ARGUMENT — bad input (query unsupported without index)

INDEX_REQUIRED — query needs composite index (provide hint)

Error objects include standardized fields: code, message, details (JSON).

24 — Contributing, license & governance

License suggestion: Apache 2.0 (friendly to commercial use).

Contribution guide: PR process, code style, testing requirements, CI.

Governance: single-owner initial repo, then open maintainers team.

25 — Example minimal README (starter)

A concise README should include:

What FireLocal is

Quickstart (initialize, set, get)

How to enable sync via .env

How to run CLI and tests

Link to API reference