use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};

/// FireLocal configuration loaded from .env or environment variables
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FireLocalConfig {
    pub project_id: String,
    pub db_path: PathBuf,
    pub sync_mode: SyncMode,
    pub sync_interval: u64, // seconds

    // Firebase credentials (optional, only if syncing)
    pub firebase_api_key: Option<String>,
    pub firebase_app_id: Option<String>,
    pub firebase_project_id: Option<String>,
    pub firebase_client_email: Option<String>,
    pub firebase_private_key: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SyncMode {
    Off,
    Live,
    Batch,
    Background,
}

impl Default for FireLocalConfig {
    fn default() -> Self {
        Self {
            project_id: "firelocal-default".to_string(),
            db_path: PathBuf::from("./.firelocal/data"),
            sync_mode: SyncMode::Off,
            sync_interval: 300,
            firebase_api_key: None,
            firebase_app_id: None,
            firebase_project_id: None,
            firebase_client_email: None,
            firebase_private_key: None,
        }
    }
}

impl FireLocalConfig {
    /// Load configuration from .env file or environment variables
    /// If .env doesn't exist, create it with template
    /// If .env exists but is incomplete, populate missing fields
    pub fn load_or_create(project_root: Option<&Path>) -> Result<Self> {
        let root = project_root.unwrap_or_else(|| Path::new("."));
        let env_path = root.join(".env");

        // Check if .env exists
        if !env_path.exists() {
            // Create new .env with template
            Self::create_env_template(&env_path)?;
            println!("✓ Created .env file at {}", env_path.display());
        } else {
            // Populate missing fields in existing .env
            Self::populate_env_file(&env_path)?;
        }

        // Load environment variables from .env
        if let Err(e) = dotenv::from_path(&env_path) {
            eprintln!("Warning: Could not load .env file: {}", e);
        }

        // Parse configuration from environment
        Self::from_env()
    }

    /// Create a new .env file with template
    fn create_env_template(path: &Path) -> Result<()> {
        let template = r#"# FireLocal Configuration
# Auto-generated by FireLocal

# Project Configuration
FIRELOCAL_PROJECT_ID=my-firelocal-project
FIRELOCAL_DB_PATH=./.firelocal/data
FIRELOCAL_SYNC_MODE=off
FIRELOCAL_SYNC_INTERVAL=300

# Firebase Credentials (optional, only needed if FIRELOCAL_SYNC_MODE != off)
# Uncomment and fill in your Firebase credentials to enable sync
# FIREBASE_API_KEY=your-api-key-here
# FIREBASE_APP_ID=your-app-id-here
# FIREBASE_PROJECT_ID=your-firebase-project-id
# FIREBASE_CLIENT_EMAIL=service-account@your-project.iam.gserviceaccount.com
# FIREBASE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\nYOUR_PRIVATE_KEY_HERE\n-----END PRIVATE KEY-----"

# Security Note: Never commit .env to version control!
# Add .env to your .gitignore file.
"#;

        fs::write(path, template).context("Failed to create .env template")?;
        Ok(())
    }

    /// Populate missing fields in existing .env file
    fn populate_env_file(path: &Path) -> Result<()> {
        // Read existing .env content
        let existing_content = fs::read_to_string(path).context("Failed to read .env file")?;

        // Parse existing key-value pairs
        let mut existing_keys = HashMap::new();
        for line in existing_content.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with('#') {
                continue;
            }
            if let Some(idx) = line.find('=') {
                let key = line[..idx].trim();
                existing_keys.insert(key.to_string(), true);
            }
        }

        // Required keys with default values
        let required_keys = vec![
            ("FIRELOCAL_PROJECT_ID", "my-firelocal-project"),
            ("FIRELOCAL_DB_PATH", "./.firelocal/data"),
            ("FIRELOCAL_SYNC_MODE", "off"),
            ("FIRELOCAL_SYNC_INTERVAL", "300"),
        ];

        // Optional keys (commented out by default)
        let optional_keys = vec![
            "FIREBASE_API_KEY",
            "FIREBASE_APP_ID",
            "FIREBASE_PROJECT_ID",
            "FIREBASE_CLIENT_EMAIL",
            "FIREBASE_PRIVATE_KEY",
        ];

        // Check if any keys are missing
        let mut missing_required = Vec::new();
        let mut missing_optional = Vec::new();

        for (key, default_val) in &required_keys {
            if !existing_keys.contains_key(*key) {
                missing_required.push((*key, *default_val));
            }
        }

        for key in &optional_keys {
            if !existing_keys.contains_key(*key) {
                missing_optional.push(*key);
            }
        }

        // If nothing is missing, return
        if missing_required.is_empty() && missing_optional.is_empty() {
            return Ok(());
        }

        // Append missing keys to .env
        let mut additions = String::new();
        additions.push_str("\n# Auto-populated by FireLocal\n");

        if !missing_required.is_empty() {
            additions.push_str("\n# Missing required configuration:\n");
            for (key, default_val) in missing_required {
                additions.push_str(&format!("{}={}\n", key, default_val));
            }
        }

        if !missing_optional.is_empty() {
            additions.push_str("\n# Missing optional configuration (uncomment to use):\n");
            for key in missing_optional {
                let placeholder = match key {
                    "FIREBASE_API_KEY" => "your-api-key-here",
                    "FIREBASE_APP_ID" => "your-app-id-here",
                    "FIREBASE_PROJECT_ID" => "your-firebase-project-id",
                    "FIREBASE_CLIENT_EMAIL" => {
                        "service-account@your-project.iam.gserviceaccount.com"
                    }
                    "FIREBASE_PRIVATE_KEY" => {
                        "\"-----BEGIN PRIVATE KEY-----\\nYOUR_PRIVATE_KEY_HERE\\n-----END PRIVATE KEY-----\""
                    }
                    _ => "value-here",
                };
                additions.push_str(&format!("# {}={}\n", key, placeholder));
            }
        }

        // Append to existing file
        let mut updated_content = existing_content;
        updated_content.push_str(&additions);
        fs::write(path, updated_content).context("Failed to update .env file")?;

        println!("✓ Populated .env with missing fields");
        Ok(())
    }

    /// Parse configuration from environment variables
    fn from_env() -> Result<Self> {
        let project_id = std::env::var("FIRELOCAL_PROJECT_ID")
            .unwrap_or_else(|_| "firelocal-default".to_string());

        let db_path =
            std::env::var("FIRELOCAL_DB_PATH").unwrap_or_else(|_| "./.firelocal/data".to_string());

        let sync_mode_str =
            std::env::var("FIRELOCAL_SYNC_MODE").unwrap_or_else(|_| "off".to_string());

        let sync_mode = match sync_mode_str.to_lowercase().as_str() {
            "live" => SyncMode::Live,
            "batch" => SyncMode::Batch,
            "background" => SyncMode::Background,
            _ => SyncMode::Off,
        };

        let sync_interval = std::env::var("FIRELOCAL_SYNC_INTERVAL")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(300);

        Ok(Self {
            project_id,
            db_path: PathBuf::from(db_path),
            sync_mode,
            sync_interval,
            firebase_api_key: std::env::var("FIREBASE_API_KEY").ok(),
            firebase_app_id: std::env::var("FIREBASE_APP_ID").ok(),
            firebase_project_id: std::env::var("FIREBASE_PROJECT_ID").ok(),
            firebase_client_email: std::env::var("FIREBASE_CLIENT_EMAIL").ok(),
            firebase_private_key: std::env::var("FIREBASE_PRIVATE_KEY").ok(),
        })
    }

    /// Check if sync is enabled
    pub fn is_sync_enabled(&self) -> bool {
        self.sync_mode != SyncMode::Off
    }

    /// Validate Firebase credentials if sync is enabled
    pub fn validate(&self) -> Result<()> {
        if self.is_sync_enabled() {
            if self.firebase_api_key.is_none() {
                anyhow::bail!("FIREBASE_API_KEY is required when sync is enabled");
            }
            if self.firebase_project_id.is_none() {
                anyhow::bail!("FIREBASE_PROJECT_ID is required when sync is enabled");
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    #[test]
    fn test_default_config() {
        let config = FireLocalConfig::default();
        assert_eq!(config.project_id, "firelocal-default");
        assert_eq!(config.sync_mode, SyncMode::Off);
        assert!(!config.is_sync_enabled());
    }

    #[test]
    fn test_create_env_template() {
        let test_dir = "tmp_config_test";
        let _ = fs::remove_dir_all(test_dir);
        fs::create_dir_all(test_dir).unwrap();

        let env_path = Path::new(test_dir).join(".env");
        FireLocalConfig::create_env_template(&env_path).unwrap();

        assert!(env_path.exists());
        let content = fs::read_to_string(&env_path).unwrap();
        assert!(content.contains("FIRELOCAL_PROJECT_ID"));
        assert!(content.contains("FIRELOCAL_SYNC_MODE"));

        let _ = fs::remove_dir_all(test_dir);
    }

    #[test]
    fn test_populate_env_file() {
        let test_dir = "tmp_populate_test";
        let _ = fs::remove_dir_all(test_dir);
        fs::create_dir_all(test_dir).unwrap();

        let env_path = Path::new(test_dir).join(".env");

        // Create partial .env
        fs::write(&env_path, "FIRELOCAL_PROJECT_ID=test-project\n").unwrap();

        // Populate missing fields
        FireLocalConfig::populate_env_file(&env_path).unwrap();

        let content = fs::read_to_string(&env_path).unwrap();
        assert!(content.contains("FIRELOCAL_PROJECT_ID=test-project"));
        assert!(content.contains("FIRELOCAL_DB_PATH"));
        assert!(content.contains("FIRELOCAL_SYNC_MODE"));

        let _ = fs::remove_dir_all(test_dir);
    }
}
